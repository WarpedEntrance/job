[{"title":"Styles","type":0,"sectionRef":"#","url":"/testdocss/docs/styles","content":"","keywords":""},{"title":"useStyle​","type":1,"pageTitle":"Styles","url":"/testdocss/docs/styles#usestyle","content":"Returns the current style information, with styles that are set more recently in the tree overriding styles that were set further up. In this way, styles cascade downwards, similar to CSS. "},{"title":"setStyle​","type":1,"pageTitle":"Styles","url":"/testdocss/docs/styles#setstyle","content":"Defines style for any subsequent calls in this scope. Merges with any existing styles. "},{"title":"Default styles​","type":1,"pageTitle":"Styles","url":"/testdocss/docs/styles#default-styles","content":"By default, these styles are used. You can override them anywhere: { bg1 = Color3.fromRGB(31, 31, 31), bg2 = Color3.fromRGB(42, 42, 42), bg3 = Color3.fromRGB(54, 54, 54), mutedTextColor = Color3.fromRGB(147, 147, 147), textColor = Color3.fromRGB(255, 255, 255), }  "},{"title":"Plasma","type":0,"sectionRef":"#","url":"/testdocss/docs/intro","content":"","keywords":""},{"title":"What is immediate mode?​","type":1,"pageTitle":"Plasma","url":"/testdocss/docs/intro#what-is-immediate-mode","content":"Plasma is an immediate mode UI library, as opposed to retained mode. In a retained mode model, you might make a button and connect a clicked event, with code that is invoked when the event happens. The button is retained in the DataModel, and to change the text on it you need to store a reference to it. But under an immediate mode model, you show the button and check if it's been clicked immediately, and you do that every single frame (60 times per second). There's no need for a clicked event or to store a reference to the button. As another example, let's say you had a window that you only wanted to be shown when it was visible. In retained mode, you would create the window, and store a reference to the window. When the button to toggle visibility is toggled, you use the reference to the window to make it visible or not. In immediate mode, it's much simpler: you just check if the window should be rendered with an if statement, and render the window inside the if statement. That's it: if the window wasn't supposed to be rendered, you just never call the code to render the window. "},{"title":"Advantages​","type":1,"pageTitle":"Plasma","url":"/testdocss/docs/intro#advantages","content":"The main advantage of immediate mode is that code becomes vastly simpler: You never need to have any on-click handlers and callbacks that disrupts your code flow.You don't have to worry about a lingering callback calling something that is gone.Your GUI code can easily live in a simple function (no need for an object just for the UI).You don't have to worry about world and GUI state being out-of-sync (i.e. the GUI showing something outdated), because the GUI isn't storing any state - it is showing the latest state immediately. In other words, a whole lot of code, complexity and bugs are gone, and you can focus your time on something more interesting than writing GUI code. "},{"title":"Performance​","type":1,"pageTitle":"Plasma","url":"/testdocss/docs/intro#performance","content":"Your UI code runs every frame, but we only make changes to the DataModel as needed. If you created a window, button, and checkbox in the exact same place last frame, we just do nothing this frame. We only make changes to the DataModel when something ends up being different than the last frame. This means that if your UI is not any different than it was last time, the only overhead you have is actually calling the functions to create the UI. It's not free, and using immediate-mode UI can end up using more CPU time than a retained mode UI, but it's also shouldn't be a significant enough of an overhead to cause problems. Computers are pretty fast. "},{"title":"Usage details","type":0,"sectionRef":"#","url":"/testdocss/docs/details","content":"","keywords":""},{"title":"Hooks​","type":1,"pageTitle":"Usage details","url":"/testdocss/docs/details#hooks","content":"Hooks are topologically-aware functions. This means that when you use a hook like useState or useEffect, they are aware of the call stack and hold their own state outside of arguments and return values. Their state is actually keyed by your script name and the line number you call them on! This state is kept in the enclosing scope. Scopes are created every time you use a new widget or create children inside of a widget. You can also create a new scope manually with the Plasma.scope function. Even if code runs multiple times in a single frame, state will always be separated by scope. This means you can use the same widget multiple times in a single frame, and their state will be separate because they are all inside of separate scopes. If called in a loop, hooks hold state by number of times that line was called consecutively. Check out the API reference to learn more. "},{"title":"Automatic layout​","type":1,"pageTitle":"Usage details","url":"/testdocss/docs/details#automatic-layout","content":"Widgets are automatically laid out with Roblox's Layout objects. This means you don't need to worry about where UI elements go, they just go after whatever came before them. By default, widgets are laid out vertically. You can lay widgets out horizontally by using Plasma.row(function() end) and creating widgets inside the children function to lay widgets out to the side. In the future, there will be more widgets that allow users to customize layout more easily. Plasma automatically sets the LayoutOrder property of children widgets to the correct value. "},{"title":"Error reporting​","type":1,"pageTitle":"Usage details","url":"/testdocss/docs/details#error-reporting","content":"By default, errors that occur during layout are reported visually in the UI, bounded at the scope level.  Since your code runs every frame, errors that happen every frame can fill up the output quickly. To mitigate this, Plasma will only allow repeated errors to be reported in the output once every 10 seconds:  "},{"title":"Getting Started","type":0,"sectionRef":"#","url":"/testdocss/docs/getting-started","content":"Getting Started Your UI code is intended to run on every frame. To get started with Plasma, the first step is to set up an event loop: local ReplicatedStorage = game:GetService(&quot;ReplicatedStorage&quot;) local Players = game:GetService(&quot;Players&quot;) local PlayerGui = Players.LocalPlayer:WaitForChild(&quot;PlayerGui&quot;) local RunService = game:GetService(&quot;RunService&quot;) local Plasma = require(ReplicatedStorage.Plasma) local screenGui = Instance.new(&quot;ScreenGui&quot;) screenGui.Name = &quot;Plasma&quot; screenGui.Parent = PlayerGui local root = Plasma.new(screenGui) RunService.Heartbeat:Connect(function() Plasma.start(root, function() Plasma.window(&quot;Hello plasma!&quot;, function() if Plasma.button(&quot;Say hello&quot;):clicked() then print(&quot;Hello world!&quot;) end end) end) end) In the above code sample, we call Plasma.new, passing in the root instance where we want our UI to end up, in this case it's a ScreenGui. Plasma.new returns an object which holds state about our UI. You don't need to interact with this object, just keep it around so we can pass it into Plasma later. We create an event connected to Heartbeat, and every heartbeat event, we call Plasma.start with our root and a function that creates the UI. The function we pass to Plasma.start cannot yield (doing so will error). Inside, we can create our UI using Plasma's widgets. From here, you should look at the API reference to check out all the other available widgets!","keywords":""},{"title":"Creating Custom Widgets","type":0,"sectionRef":"#","url":"/testdocss/docs/creating-widgets","content":"","keywords":""},{"title":"Only updating properties when necessary with useEffect​","type":1,"pageTitle":"Creating Custom Widgets","url":"/testdocss/docs/creating-widgets#only-updating-properties-when-necessary-with-useeffect","content":"Typically, setting properties every frame is not that expensive of an operation, but if you only wanted to set Text and TextColor3 when their arguments actually changed, we can use the useEffect hook: Plasma.useEffect(function() label.Text = text label.TextColor3 = color end, text, color)  Now, this code will only ever be invoked if text or color actually changes from the last run. "},{"title":"Persistent state with the useState hook​","type":1,"pageTitle":"Creating Custom Widgets","url":"/testdocss/docs/creating-widgets#persistent-state-with-the-usestate-hook","content":"Let's make a counter button! The button's text should increase by 1 every time we click it. myButton.lua local Plasma = require(ReplicatedStorage.Plasma) return Plasma.widget(function(text, color) local times, setTimes = Plasma.useState(0) -- new! local refs = Plasma.useInstance(function(ref) return Plasma.create(&quot;TextButton&quot;, { -- snip -- Activated = function() -- new! setTimes(function(last) return last + 1 end) end, }) end) refs.button.Text = text .. &quot; &quot; .. times -- new! end)  (Extraneous lines have been removed from the above example) Now, every time the user clicks this button, it'll concatenate the text they passed in with the number of times the button's been pressed.  A note on useState with useInstance and useEffect Notice that we pass a function to setTimes. What would have happened if we just wrote setTimes(times + 1) instead? It would only go to 1! This is because (as we mentioned above), the code inside useInstance only ever runs once, when the widget is created. This means that the times variable the useInstance closure captured is always going to be 0. In the main scope of the widget function, times is what you expect, because it does run every frame. But inside useInstance or useEffect functions, times is always going to be what it was when those functions ran. That's why the set callback (setTimes) can be given a function, which is invoked immediately with the current value of times. Problem solved! "},{"title":"Getting information out of widgets​","type":1,"pageTitle":"Creating Custom Widgets","url":"/testdocss/docs/creating-widgets#getting-information-out-of-widgets","content":"Let's say you want your users to be able to see how many times your button was clicked in their code when they use your button widget. You already know how to do this: just return it! At the bottom of your widget, just: return { times = times }  tip Returning a table with named values instead of returning a value directly is recommended, because it allows you to add more return values in the future without breaking your API interface. Then, when you use your button widget, you can just check it! Using your widget Plasma.start(root, function() Plasma.window(&quot;Button&quot;, function() local timesClicked = myButton(&quot;hi&quot;, Color3.fromRGB(255, 153, 0)).times if timesClicked &gt; 50 then Plasma.label(&quot;You clicked them all!&quot;) end end) end)  "},{"title":"Nested widgets​","type":1,"pageTitle":"Creating Custom Widgets","url":"/testdocss/docs/creating-widgets#nested-widgets","content":"You can use widgets inside of other widgets. For example, you could blur the world only if the number of times clicked is even: if times % 2 == 0 then Plasma.blur(20) end  "},{"title":"Automatic size​","type":1,"pageTitle":"Creating Custom Widgets","url":"/testdocss/docs/creating-widgets#automatic-size","content":"Roblox has an automatic size property of GuiObjects, but it doesn't always work correctly, especially with padding. Plasma comes with an alternative automatic sizing function: automaticSize. To use it, just call automaticSize inside your useInstance function, passing in your root frame. "}]